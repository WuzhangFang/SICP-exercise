;;; Sequence operations: maps, filters, accumulates
; though filter is a built-in procedure, we still write it
(load "fib.scm")
(define (filter-1 predicate sequence)
    (cond ((null? sequence) `())
          ((predicate (car sequence)) (cons (car sequence) 
                                            (filter-1 predicate (cdr sequence))))
          (else (filter-1 predicate (cdr sequence)))))
(define (enumerate-tree tree)
    (cond ((null? tree) `())
          ((not (pair? tree)) (list tree))
          (else (append (enumerate-tree (car tree)) (enumerate-tree (cdr tree))))))
(define (enumerate-interval low high)
    (if (> low high) `()
        (cons low (enumerate-interval (+ 1 low) high))))
(define (accumulate operation initial sequence)
    (if (null? sequence) initial
        (operation (car sequence) (accumulate operation initial (cdr sequence)))))
(define (accumulate-n op init seqs)
    (if (null? (car seqs))
        `()
        (cons (accumulate op init (map car seqs)) (accumulate-n op init (map cdr seqs)))))
(define (flatmap proc seq)
    (accumulate append `() (map proc seq)))
;(define (sum-odd-squares tree)
;    (accumulate + 0 (map square (filter odd? (enumerate-tree tree)))))
;(define (even-fib n)
;    (accumulate cons `() (filter even? (map fib1 (enumerate-interval 0 n)))))
;(sum-odd-squares (list 1 2 3 4 5 6))
;(even-fib 6)
